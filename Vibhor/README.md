## Overall Parser Structure

Token Stream Input:
Receives a stream of tokens generated by the lexer.

Pointer & Lookahead:
Maintains a pointer into the token stream with utility functions like peek() and consume().

AST Construction:
Builds an Abstract Syntax Tree (AST) that mirrors the structure of the source code.

Error Handling:
To be Discussed

## Parsing Functions and Their Responsibilities

1. parseProgram()
Entry point that iterates through tokens until EOF and delegates to specialized parsing functions.

2. parseFunctionDeclaration()
Handles fn declarations, including function names, parameter lists, return types (via ->), and function bodies.

3. parseParameterList()
Parses comma-separated parameters within parentheses, ensuring each parameter has an identifier and a type.

4. parseVariableDeclaration()
Processes var declarations, handling identifiers, optional type annotations, and initializers.

5. parseStatement()
Dispatches the parsing of different statement types (e.g., if, return, loops, expression statements).

6. parseReturnStatement()
Parses return statements, ensuring proper expression parsing and statement termination.

7. parseIfStatement()
Parses conditional statements (if and optional else blocks) including the evaluation of conditions and associated code blocks.

8. parseLoopStatements()
Handles loop constructs (e.g., loop for while-like loops and forloop for for-like loops) by parsing conditions/control parameters and loop bodies.

9. parseExpression()
Parses arithmetic and logical expressions, managing operator precedence and nested sub-expressions.



